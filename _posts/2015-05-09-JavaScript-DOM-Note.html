---
layout: post
title:  "JavaScript DOM Note"
date:  2015-05-07
categories: Books_of_code
featured_image: /images/JavaScriptDOM.jpg

---

<h2>《JavaScript DOM 编程艺术》 笔记摘抄(更新中)</h2>

<section>
    <p>
        <h3>[DOM操作两项原则]</h3>
        <b>渐进增强(progressive enhancement)</b>
        <blockquote>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;渐进增强原则基于这样一种思想：你应该总是从最核心的部分，也就是从内容开始。
            应该根据内容使用标记良好的结构；然后再逐步加强这些内容。
            这些增强工作既可以是通过CSS改进呈现效果，也可以是通过DOM添加各种行为。
        </blockquote>
        <b>平稳退化</b>
        <blockquote>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            渐进增强的实现必然支持平稳退化。
            如果你按照渐进增强的原则去充实内容，你为内容添加的样式和行为就自然支持平稳退化。
            那些缺乏必要的CSS和DOM支持的访问者仍可以访问到你的核心内容。
        </blockquote>
    </p>
</section>
<section>
    <p>
        <h3>[CSS-DOM]</h3>
        <b>三位一体的网页</b>
        <ul>
            <li><span>[ 结构层 structural layer ]</span></li>
            <blockquote>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                结构层由HTML或XHTML之类的标记语言负责创建。
                标签(tag) 对网页内容的语义做出了描述。
            </blockquote>
            <li><span>[ 表示层 presentation layer ]</span></li>
            <blockquote>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                表示层由CSS完成。CSS描述页面内容应该如何呈现。
            </blockquote>
            <li><span>[ 行为层 behavior layer ]</span></li>
            <blockquote>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                行为层负责内容应该如何响应事件这一问题。这是JavaScript和DOM主宰的领域。
            </blockquote>
        </ul>

        <b>分离</b>
        <blockquote>
            <ul>
                <li>使用(X)HTML去搭建文档的结构</li>
                <li>使用CSS去设置文档的呈现效果</li>
                <li>使用DOM脚本去实现文档的行为</li>
            </ul>
        </blockquote>

        <b>使用CSS还是DOM?</b>
        <blockquote>
            <ul>
                <li>选择这个问题最简单的解决方案</li>
                <li>选择会得到更多浏览器的支持的解决方案</li>
            </ul>
        </blockquote>
    </p>
</section>

<section>
    <p>
        <h3>[nodeType常用值]</h3>
        <blockquote>
            <ul>
                <li><span>元素节点</span> nodeType属性为为 <span>1<span></li>
                <li><span>属性节点</span> nodeType属性为为 <span>2<span></li>
                <li><span>文本节点</span> nodeType属性为为 <span>3<span></li>
            </ul>
        </blockquote>
    </p>
</section>

<section>
    <p>
        <h3>[封装函数]</h3>
        <b>getElementsByClassName(node,classname) —— 兼容老浏览器</b>
        <p>
{% highlight javascript %}

function getElementsByClassName(node,classname) {
    if(node.getElementsByClassName) {
        //使用现有方法
        return node.getElementsByClassName(classname);
    }
    else{
        var results = new Array();
        var elems = node.getElementsByTagName("*");
        for(var i=0;i &lt; elems.length;i++){
            if(elems[i].className.indexOf(classname) != -1) {
            results[results.length] = elems[i];
            }
        }
        return results;
    }
}

{% endhighlight %}
        </p>

        <b>getNextElement() —— 获取下一个元素节点</b>
        <p>
{% highlight javascript %}

function getNextElement(node) {
    if(node.nodeType == 1) {
        return node;
    }
    if(node.nextSibling) {
        return getNextElement(node.nextSibling);
    }
    return null;
}

{% endhighlight %}
        </p>

        <b>addLoadEvent() —— 共享onload事件</b>
        <p>
{% highlight javascript %}

function addLoadEvent(func) {
    var oldonload = window.onload;
    if(typeof window.onload != 'function') {
        window.onload = func;
    }
    else {
        window.onload = function(){
            oldonload();
            func();
        }
    }
}

{% endhighlight %}
        </p>
        
        <b>insertAfter() —— 在某元素后插入新元素</b>
        <p>
{% highlight javascript %}

//DOM已提供，在某元素之前插入新元素
insertBefore(newElement,targetElement) 

function insertAfter(newElement,targetElement) {
    var parent = targetElement.parentNode();
    if(parent.lastChild == targetElement){
        parent.appendChild(newElement);
    }
    else{
        parent.insertBefore(newElement,targetElement.nextSibling);
    }
}

{% endhighlight %}
        </p>

        <b>addClass() —— 添加新的className</b>
        <p>
{% highlight javascript %}

function addClass(element,value) {
    //判断className属性是否为空
    if(!element.className) {
    element.className = value;
    }
    else {
    //若不为空，把空格和新的class设置值追加到className属性上去
    newClassName = element.className;
    newClassName += " ";
    newClassName += value;
    element.className = newClassName;
    }
}

{% endhighlight %}
        </p>
    </p>
</section>